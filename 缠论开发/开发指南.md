# 缠论AI Vibe Coding完整实现指南

## 一、核心架构与设计原则

### 1. 系统架构
```python
class ChanTheorySystem:
    """
    缠论系统核心架构：
    数据流：K线 → 处理K线 → 分型 → 笔 → 线段 → 中枢 → 走势类型 → 买卖点
    递归性：高级别结构由低级别递归构成
    状态机：每个结构都有明确的开始、延续、结束状态
    """
```

### 2. 参数配置
```python
CONFIG_TEMPLATE = {
    "stock": {
        "min_price_gap": 0.01,
        "min_k_count": 5,
        "overlap_ratio": 0.2
    },
    "future": {
        "min_price_gap": 0.002,
        "min_k_count": 3,
        "overlap_ratio": 0.15
    },
    "forex": {
        "min_price_gap": 0.0005,
        "min_k_count": 8,
        "overlap_ratio": 0.25
    }
}
```

## 二、K线包含关系处理

```python
class KLineProcessor:
    """K线包含关系处理（确定性、无未来函数）"""
    
    @staticmethod
    def process_include_relationship(k_lines):
        if len(k_lines) < 2:
            return k_lines
        
        processed = []
        direction = None  # "up" or "down"
        
        for i in range(len(k_lines)):
            if not processed:
                processed.append(k_lines[i])
                continue
            
            last = processed[-1]
            current = k_lines[i]
            
            # 判断包含关系
            is_include = (last["high"] >= current["high"] and last["low"] <= current["low"]) or \
                         (current["high"] >= last["high"] and current["low"] <= last["low"])
            
            if not is_include:
                processed.append(current)
                # 更新方向
                if len(processed) >= 2:
                    prev = processed[-2]
                    if current["high"] > prev["high"]:
                        direction = "up"
                    else:
                        direction = "down"
                continue
            
            # 处理包含关系
            if direction is None:
                direction = "up"
            
            if direction == "up":
                # 向上处理：取高高
                new_k = {
                    "high": max(last["high"], current["high"]),
                    "low": max(last["low"], current["low"]),
                    "open": last["open"],
                    "close": current["close"],
                    "volume": last["volume"] + current["volume"]
                }
            else:
                # 向下处理：取低低
                new_k = {
                    "high": min(last["high"], current["high"]),
                    "low": min(last["low"], current["low"]),
                    "open": last["open"],
                    "close": current["close"],
                    "volume": last["volume"] + current["volume"]
                }
            
            processed[-1] = new_k
        
        return processed
```

## 三、分型识别

```python
class FractalDetector:
    """顶底分型识别"""
    
    @staticmethod
    def find_fractals(processed_k_lines):
        fractals = []
        
        for i in range(1, len(processed_k_lines) - 1):
            left = processed_k_lines[i-1]
            middle = processed_k_lines[i]
            right = processed_k_lines[i+1]
            
            # 顶分型：中间K线高点最高、低点最高
            is_top = (middle["high"] > left["high"] and 
                     middle["high"] > right["high"] and
                     middle["low"] > left["low"] and
                     middle["low"] > right["low"])
            
            # 底分型：中间K线低点最低、高点最低
            is_bottom = (middle["low"] < left["low"] and
                        middle["low"] < right["low"] and
                        middle["high"] < left["high"] and
                        middle["high"] < right["high"])
            
            if is_top:
                fractals.append({
                    "type": "top",
                    "index": i,
                    "price": middle["high"],
                    "k_line": middle
                })
            elif is_bottom:
                fractals.append({
                    "type": "bottom",
                    "index": i,
                    "price": middle["low"],
                    "k_line": middle
                })
        
        return fractals
    
    @staticmethod
    def validate_fractals(fractals, min_distance=3):
        """分型验证：去除无效分型"""
        if not fractals:
            return []
        
        valid_fractals = [fractals[0]]
        
        for i in range(1, len(fractals)):
            current = fractals[i]
            last_valid = valid_fractals[-1]
            
            distance = abs(current["index"] - last_valid["index"])
            
            if (distance >= min_distance and 
                ((last_valid["type"] == "top" and current["type"] == "bottom" and 
                  current["price"] < last_valid["price"]) or
                 (last_valid["type"] == "bottom" and current["type"] == "top" and
                  current["price"] > last_valid["price"]))):
                valid_fractals.append(current)
        
        return valid_fractals
```

## 四、笔识别（完整处理延伸与破坏）

```python
class Stroke:
    """笔的完整定义"""
    def __init__(self):
        self.start_fractal = None
        self.end_fractal = None
        self.temp_end = None
        self.direction = None  # "up" or "down"
        self.status = "forming"  # "forming", "confirmed", "extended", "broken"
        self.strokes_inside = []

class StrokeDetector:
    """笔识别算法（处理所有边界情况）"""
    
    def __init__(self, config):
        self.config = config
        self.strokes = []
        self.current_stroke = None
        
    def process_new_fractal(self, fractal, k_lines):
        """处理新分型，动态更新笔"""
        if self.current_stroke is None:
            self._start_new_stroke(fractal)
            return
        
        current_type = self.current_stroke.direction
        new_fractal_type = "up" if fractal["type"] == "bottom" else "down"
        
        if new_fractal_type != current_type:
            # 反向分型
            if self._can_form_new_stroke(fractal):
                self._end_current_stroke(fractal)
                self._start_new_stroke(fractal)
            else:
                # 不够条件形成新笔，当前笔延伸
                self._extend_current_stroke(fractal)
        else:
            # 同向分型，更新笔的起点或终点
            self._update_stroke_end(fractal)
    
    def _can_form_new_stroke(self, new_fractal):
        """判断是否能形成新笔的精确条件"""
        if self.current_stroke.end_fractal is None:
            return False
        
        start = self.current_stroke.end_fractal
        end = new_fractal
        
        # 1. 检查K线数量
        k_count = abs(end["index"] - start["index"])
        if k_count < self.config["min_k_count"]:
            return False
        
        # 2. 检查价格关系
        if start["type"] == "top" and end["type"] == "bottom":
            if end["price"] >= start["price"] * 0.999:
                return False
        elif start["type"] == "bottom" and end["type"] == "top":
            if end["price"] <= start["price"] * 1.001:
                return False
        
        # 3. 检查中间是否有更极端的K线破坏笔的结构
        if not self._check_stroke_integrity(start, end):
            return False
        
        # 4. 检查最低价格变动要求
        price_change = abs(end["price"] - start["price"])
        avg_price = (end["price"] + start["price"]) / 2
        if price_change / avg_price < self.config["min_price_gap"]:
            return False
        
        return True
    
    def _extend_current_stroke(self, new_fractal):
        """笔的延伸：临时结束分型更新"""
        if new_fractal["type"] == self.current_stroke.end_fractal["type"]:
            if self.current_stroke.direction == "up":
                # 上升笔：取更高的顶分型
                if new_fractal["price"] > self.current_stroke.end_fractal["price"]:
                    self.current_stroke.end_fractal = new_fractal
            else:
                # 下降笔：取更低的底分型
                if new_fractal["price"] < self.current_stroke.end_fractal["price"]:
                    self.current_stroke.end_fractal = new_fractal
            
            self.current_stroke.status = "extended"
    
    def _update_stroke_end(self, new_fractal):
        """更新笔的终点（同向分型）"""
        if self.current_stroke.direction == "up":
            # 上升笔：遇到更高的底分型（笔的起点更新）
            if new_fractal["price"] < self.current_stroke.start_fractal["price"]:
                self.current_stroke.start_fractal = new_fractal
        else:
            # 下降笔：遇到更低的顶分型
            if new_fractal["price"] > self.current_stroke.start_fractal["price"]:
                self.current_stroke.start_fractal = new_fractal
    
    def _check_stroke_integrity(self, start_fractal, end_fractal, k_lines):
        """检查笔的完整性：中间不能有更极端的价格"""
        start_idx = start_fractal["index"]
        end_idx = end_fractal["index"]
        
        if start_fractal["type"] == "bottom":  # 上升笔
            for idx in range(start_idx + 1, end_idx):
                if k_lines[idx]["low"] < start_fractal["price"] * 0.999:
                    return False
        else:  # 下降笔
            for idx in range(start_idx + 1, end_idx):
                if k_lines[idx]["high"] > start_fractal["price"] * 1.001:
                    return False
        
        return True
    
    def _start_new_stroke(self, fractal):
        """开始新笔"""
        self.current_stroke = Stroke()
        self.current_stroke.start_fractal = fractal
        self.current_stroke.direction = "up" if fractal["type"] == "bottom" else "down"
        self.current_stroke.status = "forming"
    
    def _end_current_stroke(self, end_fractal):
        """结束当前笔"""
        self.current_stroke.end_fractal = end_fractal
        self.current_stroke.status = "confirmed"
        self.strokes.append(self.current_stroke)
```

## 五、线段识别（完整特征序列法+缺口处理）

```python
class Segment:
    """线段的完整定义"""
    def __init__(self):
        self.strokes = []
        self.direction = None
        self.status = "forming"
        self.feature_sequence = []
        self.break_segment = None

class SegmentDetector:
    """线段识别的完整算法（特征序列法）"""
    
    def __init__(self):
        self.segments = []
        self.current_segment = None
        self.pending_gap = None
    
    def process_new_stroke(self, stroke):
        """处理新笔，更新线段状态"""
        # 1. 检查缺口
        if self._has_gap_between_strokes(stroke):
            self._handle_gap(stroke)
        
        # 2. 如果当前没有线段，开始新线段
        if self.current_segment is None:
            self._start_new_segment(stroke)
            return
        
        # 3. 检查是否应该开始新线段
        if self._should_start_new_segment(stroke):
            self._end_current_segment()
            self._start_new_segment(stroke)
            return
        
        # 4. 将笔添加到当前线段
        self.current_segment.strokes.append(stroke)
        
        # 5. 更新特征序列
        self._update_feature_sequence(stroke)
        
        # 6. 检查特征序列分型
        if self._check_feature_fractal():
            self.current_segment.status = "pending_break"
    
    def _has_gap_between_strokes(self, new_stroke):
        """检查是否有缺口"""
        if not self.current_segment or len(self.current_segment.strokes) == 0:
            return False
        
        last_stroke = self.current_segment.strokes[-1]
        
        if last_stroke.direction == "up" and new_stroke.direction == "down":
            # 上升笔后接下降笔，检查向上缺口
            if new_stroke.end_fractal["price"] > last_stroke.start_fractal["price"]:
                self.pending_gap = {
                    "type": "up_gap",
                    "start": last_stroke.end_fractal["price"],
                    "end": new_stroke.start_fractal["price"]
                }
                return True
        elif last_stroke.direction == "down" and new_stroke.direction == "up":
            # 下降笔后接上升笔，检查向下缺口
            if new_stroke.end_fractal["price"] < last_stroke.start_fractal["price"]:
                self.pending_gap = {
                    "type": "down_gap",
                    "start": last_stroke.end_fractal["price"],
                    "end": new_stroke.start_fractal["price"]
                }
                return True
        
        return False
    
    def _handle_gap(self, stroke):
        """处理缺口：将缺口视为一笔的特征序列元素"""
        if not self.pending_gap:
            return
        
        gap_element = {
            "type": "gap",
            "gap_type": self.pending_gap["type"],
            "high": self.pending_gap["start"],
            "low": self.pending_gap["end"],
            "is_virtual": True
        }
        
        self.current_segment.feature_sequence.append(gap_element)
        self.pending_gap = None
    
    def _update_feature_sequence(self, stroke):
        """更新特征序列"""
        if self.current_segment.direction == "up":
            # 上升线段，下降笔加入特征序列
            if stroke.direction == "down":
                element = self._stroke_to_feature_element(stroke)
                self._process_feature_element(element)
        else:
            # 下降线段，上升笔加入特征序列
            if stroke.direction == "up":
                element = self._stroke_to_feature_element(stroke)
                self._process_feature_element(element)
    
    def _stroke_to_feature_element(self, stroke):
        """将笔转换为特征序列元素"""
        return {
            "type": "stroke",
            "high": max(stroke.start_fractal["price"], stroke.end_fractal["price"]),
            "low": min(stroke.start_fractal["price"], stroke.end_fractal["price"]),
            "stroke": stroke
        }
    
    def _process_feature_element(self, new_element):
        """处理特征序列元素（包含关系处理）"""
        if not self.current_segment.feature_sequence:
            self.current_segment.feature_sequence.append(new_element)
            return
        
        last_element = self.current_segment.feature_sequence[-1]
        
        # 检查包含关系
        if self._is_feature_element_include(last_element, new_element):
            merged = self._merge_feature_elements(last_element, new_element)
            self.current_segment.feature_sequence[-1] = merged
        else:
            self.current_segment.feature_sequence.append(new_element)
    
    def _is_feature_element_include(self, elem1, elem2):
        """判断两个特征序列元素是否有包含关系"""
        return (elem1["high"] >= elem2["high"] and elem1["low"] <= elem2["low"]) or \
               (elem2["high"] >= elem1["high"] and elem2["low"] <= elem1["low"])
    
    def _merge_feature_elements(self, elem1, elem2):
        """合并包含的特征元素"""
        if self.current_segment.direction == "up":
            # 上升线段，特征序列向下，向下处理（取低低）
            high = min(elem1["high"], elem2["high"])
            low = min(elem1["low"], elem2["low"])
        else:
            # 下降线段，特征序列向上，向上处理（取高高）
            high = max(elem1["high"], elem2["high"])
            low = max(elem1["low"], elem2["low"])
        
        return {**elem1, "high": high, "low": low, "is_merged": True}
    
    def _check_feature_fractal(self):
        """检查特征序列是否形成分型"""
        sequence = self.current_segment.feature_sequence
        
        if len(sequence) < 3:
            return False
        
        for i in range(1, len(sequence) - 1):
            left = sequence[i-1]
            middle = sequence[i]
            right = sequence[i+1]
            
            if self.current_segment.direction == "up":
                # 上升线段，检查特征序列的顶分型
                if (middle["high"] > left["high"] and 
                    middle["high"] > right["high"] and
                    middle["low"] > left["low"] and
                    middle["low"] > right["low"]):
                    
                    if self._check_break_condition(sequence, i-1, i+1):
                        return True
            else:
                # 下降线段，检查特征序列的底分型
                if (middle["low"] < left["low"] and
                    middle["low"] < right["low"] and
                    middle["high"] < left["high"] and
                    middle["high"] < right["high"]):
                    
                    if self._check_break_condition(sequence, i-1, i+1):
                        return True
        
        return False
    
    def _check_break_condition(self, sequence, first_idx, third_idx):
        """检查线段破坏的确认条件"""
        first = sequence[first_idx]
        third = sequence[third_idx]
        
        if self.current_segment.direction == "up":
            # 上升线段被破坏：第三元素的最低点 < 第一元素的最低点
            return third["low"] < first["low"]
        else:
            # 下降线段被破坏：第三元素的最高点 > 第一元素的最高点
            return third["high"] > first["high"]
    
    def _should_start_new_segment(self, new_stroke):
        """判断是否应该开始新线段"""
        if len(self.current_segment.strokes) < 2:
            return False
        
        # 检查前三笔是否有重叠（线段必要条件）
        if len(self.current_segment.strokes) == 2:
            stroke1 = self.current_segment.strokes[0]
            stroke2 = self.current_segment.strokes[1]
            
            highs = [
                max(stroke1.start_fractal["price"], stroke1.end_fractal["price"]),
                max(stroke2.start_fractal["price"], stroke2.end_fractal["price"]),
                max(new_stroke.start_fractal["price"], new_stroke.end_fractal["price"])
            ]
            
            lows = [
                min(stroke1.start_fractal["price"], stroke1.end_fractal["price"]),
                min(stroke2.start_fractal["price"], stroke2.end_fractal["price"]),
                min(new_stroke.start_fractal["price"], new_stroke.end_fractal["price"])
            ]
            
            overlap_high = min(highs)
            overlap_low = max(lows)
            
            if overlap_low >= overlap_high:
                return True
        
        # 检查线段是否已被破坏
        if self.current_segment.status == "pending_break":
            return True
        
        return False
    
    def _start_new_segment(self, stroke):
        """开始新线段"""
        self.current_segment = Segment()
        self.current_segment.strokes.append(stroke)
        self.current_segment.direction = stroke.direction
    
    def _end_current_segment(self):
        """结束当前线段"""
        if len(self.current_segment.strokes) >= 3:
            self.current_segment.status = "completed"
            self.segments.append(self.current_segment)
```

## 六、中枢识别（递归与级别处理）

```python
class ZhongShu:
    """中枢的完整定义"""
    def __init__(self, level):
        self.level = level
        self.components = []
        self.gg = None  # 中枢高点
        self.dd = None  # 中枢低点
        self.zg = None  # 中枢区间高点
        self.zd = None  # 中枢区间低点
        self.status = "forming"
        self.higher_level = None

class ZhongShuDetector:
    """中枢识别的完整算法（递归）"""
    
    def __init__(self):
        self.zhongshus_by_level = {}
    
    def find_zhongshu_recursive(self, strokes, level=1, max_level=3):
        """递归寻找中枢"""
        if level > max_level:
            return []
        
        zhongshus = []
        i = 0
        
        while i < len(strokes) - 2:
            strokes_triple = strokes[i:i+3]
            
            if self._check_zhongshu_condition(strokes_triple):
                zhongshu = ZhongShu(level)
                zhongshu.components = strokes_triple
                
                self._calculate_zhongshu_range(zhongshu)
                
                # 检查中枢延伸
                extend_end = self._check_zhongshu_extend(zhongshu, strokes, i+3)
                if extend_end > i+2:
                    zhongshu.components = strokes[i:extend_end+1]
                    self._calculate_zhongshu_range(zhongshu)
                    zhongshu.status = "extending"
                    i = extend_end
                else:
                    zhongshu.status = "completed"
                
                zhongshus.append(zhongshu)
                i += 3
            else:
                i += 1
        
        # 递归寻找更高级别中枢
        for zhongshu in zhongshus:
            internal_strokes = self._extract_internal_strokes(zhongshu)
            if internal_strokes:
                higher_level_zhongshus = self.find_zhongshu_recursive(
                    internal_strokes, level + 1, max_level
                )
                zhongshu.higher_level = higher_level_zhongshus
        
        return zhongshus
    
    def _check_zhongshu_condition(self, strokes_triple):
        """检查三笔是否构成中枢"""
        if len(strokes_triple) < 3:
            return False
        
        # 检查笔的方向序列
        directions = [s.direction for s in strokes_triple]
        valid_sequences = [["up", "down", "up"], ["down", "up", "down"]]
        if directions not in valid_sequences:
            return False
        
        # 计算三笔的重叠区间
        price_ranges = []
        for stroke in strokes_triple:
            high = max(stroke.start_fractal["price"], stroke.end_fractal["price"])
            low = min(stroke.start_fractal["price"], stroke.end_fractal["price"])
            price_ranges.append({"high": high, "low": low})
        
        overlap_high = min(r["high"] for r in price_ranges)
        overlap_low = max(r["low"] for r in price_ranges)
        
        return overlap_low < overlap_high
    
    def _calculate_zhongshu_range(self, zhongshu):
        """计算中枢的四个关键价格"""
        if not zhongshu.components:
            return
        
        highs = []
        lows = []
        price_ranges = []
        
        for component in zhongshu.components:
            high = max(component.start_fractal["price"], component.end_fractal["price"])
            low = min(component.start_fractal["price"], component.end_fractal["price"])
            highs.append(high)
            lows.append(low)
            price_ranges.append({"high": high, "low": low})
        
        zhongshu.gg = max(highs)
        zhongshu.dd = min(lows)
        
        if len(zhongshu.components) >= 3:
            overlap_high = min(r["high"] for r in price_ranges[:3])
            overlap_low = max(r["low"] for r in price_ranges[:3])
            zhongshu.zg = overlap_high
            zhongshu.zd = overlap_low
        else:
            zhongshu.zg = zhongshu.gg
            zhongshu.zd = zhongshu.dd
    
    def _check_zhongshu_extend(self, zhongshu, all_strokes, start_idx):
        """检查中枢是否延伸"""
        if zhongshu.zg is None or zhongshu.zd is None:
            return start_idx - 1
        
        current_end = start_idx - 1
        
        for i in range(start_idx, len(all_strokes)):
            stroke = all_strokes[i]
            high = max(stroke.start_fractal["price"], stroke.end_fractal["price"])
            low = min(stroke.start_fractal["price"], stroke.end_fractal["price"])
            
            if high > zhongshu.zg and low < zhongshu.zd:
                current_end = i
            else:
                break
        
        return current_end
```

## 七、背驰检测

```python
class BiChiDetector:
    """背驰检测完整实现"""
    
    def detect_bi_chi(self, stroke1, stroke2, zhongshu=None, indicator="macd"):
        """检测背驰"""
        power1 = self._calculate_power(stroke1, indicator)
        power2 = self._calculate_power(stroke2, indicator)
        
        # 检查价格关系
        price_condition = False
        if stroke1.direction == "up" and stroke2.direction == "up":
            if stroke2.end_fractal["price"] > stroke1.end_fractal["price"]:
                price_condition = True
        elif stroke1.direction == "down" and stroke2.direction == "down":
            if stroke2.end_fractal["price"] < stroke1.end_fractal["price"]:
                price_condition = True
        
        # 检查力度衰减
        power_condition = power2 < power1 * 0.7
        
        # 确定背驰类型
        bi_chi_type = "unknown"
        if zhongshu:
            if self._is_trend_bi_chi(stroke1, stroke2, zhongshu):
                bi_chi_type = "trend"
            else:
                bi_chi_type = "range"
        else:
            bi_chi_type = "stroke"
        
        return {
            "has_bi_chi": price_condition and power_condition,
            "type": bi_chi_type,
            "power1": power1,
            "power2": power2,
            "ratio": power2 / power1 if power1 != 0 else 0
        }
    
    def _calculate_power(self, stroke, indicator):
        """计算走势段的力度"""
        if indicator == "macd":
            area = self._calculate_macd_area(stroke)
            return area
        elif indicator == "slope":
            price_change = abs(stroke.end_fractal["price"] - stroke.start_fractal["price"])
            time_span = stroke.end_fractal["index"] - stroke.start_fractal["index"]
            return price_change / time_span if time_span > 0 else 0
        else:
            return abs(stroke.end_fractal["price"] - stroke.start_fractal["price"])
    
    def _is_trend_bi_chi(self, stroke1, stroke2, zhongshu):
        """判断是否是趋势背驰"""
        if (stroke1.end_fractal["index"] < zhongshu.components[0].start_fractal["index"] and
            stroke2.start_fractal["index"] > zhongshu.components[-1].end_fractal["index"]):
            return True
        return False
```

## 八、买卖点识别

```python
class TradingSignalGenerator:
    """买卖点生成的完整实现"""
    
    def generate_signals(self, strokes, zhongshus, segments):
        """生成所有买卖点信号"""
        signals = []
        
        # 1. 第一类买卖点
        signals.extend(self._find_type1_signals(strokes, zhongshus))
        
        # 2. 第二类买卖点
        signals.extend(self._find_type2_signals(signals, strokes, zhongshus))
        
        # 3. 第三类买卖点
        signals.extend(self._find_type3_signals(zhongshus, strokes))
        
        # 4. 类二买、类三买
        signals.extend(self._find_class_signals(zhongshus, strokes, segments))
        
        return signals
    
    def _find_type1_signals(self, strokes, zhongshus):
        """第一类买卖点：趋势背驰点"""
        signals = []
        bi_chi_detector = BiChiDetector()
        
        for i, zs in enumerate(zhongshus):
            if i == 0:
                continue
            
            prev_zs = zhongshus[i-1]
            connecting_strokes = self._find_strokes_between_zhongshu(prev_zs, zs, strokes)
            
            if len(connecting_strokes) >= 2:
                result = bi_chi_detector.detect_bi_chi(
                    connecting_strokes[-2], 
                    connecting_strokes[-1], 
                    prev_zs
                )
                
                if result["has_bi_chi"] and result["type"] == "trend":
                    last_stroke = connecting_strokes[-1]
                    signal = {
                        "type": "buy1" if last_stroke.direction == "down" else "sell1",
                        "price": last_stroke.end_fractal["price"],
                        "zhongshu": prev_zs,
                        "strength": result["ratio"]
                    }
                    signals.append(signal)
        
        return signals
    
    def _find_type2_signals(self, type1_signals, strokes, zhongshus):
        """第二类买卖点"""
        signals = []
        
        for t1_signal in type1_signals:
            signal_index = t1_signal.get("index", 0)
            
            for i in range(signal_index + 1, len(strokes)):
                stroke = strokes[i]
                
                if t1_signal["type"] == "buy1":
                    if stroke.direction == "down":
                        signal = {
                            "type": "buy2",
                            "price": stroke.end_fractal["price"],
                            "related_type1": t1_signal
                        }
                        signals.append(signal)
                        break
                else:
                    if stroke.direction == "up":
                        signal = {
                            "type": "sell2",
                            "price": stroke.end_fractal["price"],
                            "related_type1": t1_signal
                        }
                        signals.append(signal)
                        break
        
        return signals
    
    def _find_type3_signals(self, zhongshus, strokes):
        """第三类买卖点"""
        signals = []
        
        for zs in zhongshus:
            exit_stroke = self._find_exit_stroke(zs, strokes)
            if not exit_stroke:
                continue
            
            pullback_stroke = self._find_pullback_stroke(exit_stroke, strokes)
            if not pullback_stroke:
                continue
            
            if self._check_type3_condition(zs, exit_stroke, pullback_stroke):
                signal_type = "buy3" if exit_stroke.direction == "up" else "sell3"
                signal = {
                    "type": signal_type,
                    "price": pullback_stroke.end_fractal["price"],
                    "zhongshu": zs
                }
                signals.append(signal)
        
        return signals
    
    def _check_type3_condition(self, zhongshu, exit_stroke, pullback_stroke):
        """检查三买/三卖条件"""
        if exit_stroke.direction == "up":
            return pullback_stroke.end_fractal["price"] > zhongshu.zg
        else:
            return pullback_stroke.end_fractal["price"] < zhongshu.zd
```

## 九、完整系统集成

```python
class ChanTheoryCompleteSystem:
    """完整的缠论分析系统"""
    
    def __init__(self, config):
        self.config = config
        
        self.kline_processor = KLineProcessor()
        self.fractal_detector = FractalDetector()
        self.stroke_detector = StrokeDetector(config)
        self.segment_detector = SegmentDetector()
        self.zhongshu_detector = ZhongShuDetector()
        self.signal_generator = TradingSignalGenerator()
        
        self.levels = ["1min", "5min", "30min", "daily"]
        self.results_by_level = {}
    
    def analyze_multi_level(self, klines_by_level):
        """多级别联动分析"""
        for level in self.levels:
            if level not in klines_by_level:
                continue
            
            results = self._analyze_single_level(klines_by_level[level], level)
            self.results_by_level[level] = results
        
        self._cross_level_validation()
        return self.results_by_level
    
    def _analyze_single_level(self, raw_k_lines, level):
        """单级别分析流程"""
        # 1. K线处理
        processed_k = self.kline_processor.process_include_relationship(raw_k_lines)
        
        # 2. 分型识别
        fractals = self.fractal_detector.find_fractals(processed_k)
        valid_fractals = self.fractal_detector.validate_fractals(fractals)
        
        # 3. 笔识别
        self.stroke_detector = StrokeDetector(self.config[level])
        for fractal in valid_fractals:
            self.stroke_detector.process_new_fractal(fractal, processed_k)
        strokes = self.stroke_detector.strokes
        
        # 4. 线段识别
        for stroke in strokes:
            self.segment_detector.process_new_stroke(stroke)
        segments = self.segment_detector.segments
        
        # 5. 中枢识别
        zhongshus = self.zhongshu_detector.find_zhongshu_recursive(strokes)
        
        # 6. 买卖点识别
        signals = self.signal_generator.generate_signals(strokes, zhongshus, segments)
        
        return {
            "level": level,
            "k_lines": processed_k,
            "fractals": valid_fractals,
            "strokes": strokes,
            "segments": segments,
            "zhongshus": zhongshus,
            "signals": signals
        }
```
